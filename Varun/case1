#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INFLL = (ll)4e18;

/* ----------------- Graph and utilities (adapted from your original) ----------------- */

struct Edge { int u,v; ll distance, install_cost, capacity, loss_factor; Edge(){} Edge(int a,int b,ll c,ll ic,ll cap,ll lf):u(a),v(b),distance(c),install_cost(ic),capacity(cap),loss_factor(lf){} };
struct Adj { int to; ll distance, install_cost, capacity, loss_factor; Adj* next; Adj(int t,ll d,ll ic,ll cap,ll lf):to(t),distance(d),install_cost(ic),capacity(cap),loss_factor(lf),next(nullptr){} };

struct Graph {
    int n;
    vector<Adj*> head;
    vector<Edge> edges;
    Graph():n(0){}
    Graph(int N):n(N), head(N,nullptr) {}
    void init(int N){ n=N; head.assign(n,nullptr); edges.clear(); }
    void addEdge(int u,int v,ll distance,ll install_cost,ll capacity,ll loss_factor){
        if(u<0||v<0||u>=n||v>=n) return;
        edges.emplace_back(u,v,distance,install_cost,capacity,loss_factor);
        Adj* a = new Adj(v,distance,install_cost,capacity,loss_factor);
        a->next = head[u]; head[u] = a;
        Adj* b = new Adj(u,distance,install_cost,capacity,loss_factor);
        b->next = head[v]; head[v] = b;
    }
    int size() const { return n; }
    void clear(){
        for(auto p: head){
            while(p){ Adj* tmp = p; p = p->next; delete tmp; }
        }
        head.assign(n,nullptr);
        edges.clear();
    }
    ~Graph(){ clear(); }
};

/* ----------------- DSU ----------------- */

struct DSU {
    int n; vector<int> p, r;
    DSU(int n_ = 0){ init(n_); }
    void init(int n_){ n = n_; p.resize(n); r.assign(n,0); iota(p.begin(), p.end(), 0); }
    int find(int x){ return p[x]==x?x:p[x]=find(p[x]); }
    bool unite(int a,int b){ a=find(a); b=find(b); if(a==b) return false; if(r[a]<r[b]) swap(a,b); p[b]=a; if(r[a]==r[b]) r[a]++; return true; }
};

/* ----------------- Min-heap for Prim / Dijkstra ----------------- */

struct MinHeap {
    vector<pair<ll,int>> a; // (key, v)
    vector<int> pos; // pos[v] = index in a or -1
    MinHeap(int n=0){ a.reserve(max(4,n)); pos.assign(n,-1); }
    void ensure_pos(int n){
        if((int)pos.size() < n) pos.resize(n, -1);
    }
    void swap_nodes(int i,int j){
        std::swap(a[i], a[j]);
        pos[a[i].second] = i;
        pos[a[j].second] = j;
    }
    void up(int i){
        while(i>0){
            int p=(i-1)/2;
            if(a[p].first <= a[i].first) break;
            swap_nodes(p,i);
            i=p;
        }
    }
    void down(int i){
        int n=a.size();
        while(true){
            int l=2*i+1, r=2*i+2, s=i;
            if(l<n && a[l].first < a[s].first) s=l;
            if(r<n && a[r].first < a[s].first) s=r;
            if(s==i) break;
            swap_nodes(i,s);
            i=s;
        }
    }
    void push_or_decrease(int v, ll key){
        if(v < 0) return;
        if(v >= (int)pos.size()) pos.resize(v+1, -1);
        int p = pos[v];
        if(p == -1){
            a.emplace_back(key, v);
            pos[v] = (int)a.size()-1;
            up(pos[v]);
        } else {
            if(key < a[p].first){
                a[p].first = key;
                up(p);
            }
        }
    }
    bool empty() const { return a.empty(); }
    pair<ll,int> pop(){
        auto ret = a[0];
        pos[ret.second] = -1;
        if(a.size() == 1){ a.pop_back(); return ret; }
        a[0] = a.back(); a.pop_back();
        pos[a[0].second] = 0;
        down(0);
        return ret;
    }
};

/* ----------------- Algorithms ----------------- */

struct MSTResult {
    ll total_cost;
    vector<Edge> chosen;
    MSTResult():total_cost(0){}
};

MSTResult kruskal_mst(Graph &g){
    MSTResult res;
    int n = g.n;
    if(n==0) return res;
    vector<Edge> es = g.edges;
    sort(es.begin(), es.end(), [](const Edge &a,const Edge &b){ if(a.install_cost!=b.install_cost) return a.install_cost<b.install_cost; return a.distance<b.distance; });
    DSU d(n); res.total_cost = 0;
    for(auto &e: es){
        if(e.u<0 || e.v<0) continue;
        if(d.unite(e.u,e.v)){ res.chosen.push_back(e); res.total_cost += e.install_cost; if((int)res.chosen.size()==n-1) break; }
    }
    if((int)res.chosen.size() != n-1) { res.total_cost = INFLL; res.chosen.clear(); }
    return res;
}

MSTResult prim_mst(Graph &g, int start){
    MSTResult res;
    int n = g.n;
    if(n==0) return res;
    vector<char> in_mst(n,0);
    vector<ll> best(n, INFLL);
    vector<int> parent(n, -1);
    MinHeap h(n);
    best[start]=0; h.push_or_decrease(start, 0);
    while(!h.empty()){
        auto pr = h.pop();
        int u = pr.second;
        if(in_mst[u]) continue;
        in_mst[u]=1;
        if(parent[u] != -1){
            // find the edge attributes in adjacency
            Adj* cur = g.head[u];
            bool found=false;
            Edge E;
            while(cur){
                if(cur->to == parent[u]){
                    E.u = parent[u]; E.v = u;
                    E.distance = cur->distance; E.install_cost = cur->install_cost; E.capacity = cur->capacity; E.loss_factor = cur->loss_factor;
                    found = true; break;
                }
                cur = cur->next;
            }
            if(!found){ E.u = parent[u]; E.v = u; E.distance=0; E.install_cost=best[u]; E.capacity=0; E.loss_factor=0; }
            res.chosen.push_back(E);
            if(res.total_cost < INFLL) res.total_cost += E.install_cost;
        }
        Adj* cur = g.head[u];
        while(cur){
            int v = cur->to;
            if(!in_mst[v] && cur->install_cost < best[v]){
                best[v] = cur->install_cost;
                parent[v] = u;
                h.push_or_decrease(v, best[v]);
            }
            cur = cur->next;
        }
    }
    if((int)res.chosen.size() != n-1){ res.total_cost = INFLL; res.chosen.clear(); }
    return res;
}

/* Dijkstra using weight = distance * (1000 + loss_factor) */
vector<ll> dijkstra(Graph &g, int src){
    int n = g.n;
    vector<ll> dist(n, INFLL);
    if(src<0 || src>=n) return dist;
    MinHeap h(n);
    dist[src]=0; h.push_or_decrease(src,0);
    while(!h.empty()){
        auto pr = h.pop();
        int u = pr.second; ll du = pr.first;
        if(du != dist[u]) continue;
        Adj* cur = g.head[u];
        while(cur){
            int v = cur->to;
            ll w = cur->distance * (1000 + cur->loss_factor);
            if(dist[u] + w < dist[v]){
                dist[v] = dist[u] + w;
                h.push_or_decrease(v, dist[v]);
            }
            cur = cur->next;
        }
    }
    return dist;
}

/* BFS connectivity */
void bfs(Graph &g, int start, vector<char> &vis){
    vis.assign(g.n, 0);
    if(start<0 || start>=g.n) return;
    queue<int> q; q.push(start); vis[start]=1;
    while(!q.empty()){
        int u=q.front(); q.pop();
        Adj* cur = g.head[u];
        while(cur){
            if(!vis[cur->to]){ vis[cur->to] = 1; q.push(cur->to); }
            cur = cur->next;
        }
    }
}

bool is_connected(Graph &g){
    if(g.n==0) return true;
    int start=-1;
    for(int i=0;i<g.n;i++) if(g.head[i]!=nullptr){ start=i; break; }
    if(start==-1) return (g.n<=1);
    vector<char> vis; bfs(g, start, vis);
    for(int i=0;i<g.n;i++){
        if(g.head[i] != nullptr && (i >= (int)vis.size() || !vis[i])) return false;
    }
    return true;
}

/* remove first matching edge in edge list and from adjacency lists */
bool remove_edge_uv(Graph &g, int u, int v){
    if(u<0||v<0||u>=g.n||v>=g.n) return false;
    // find in edges
    for(size_t i=0;i<g.edges.size();++i){
        Edge &e = g.edges[i];
        if((e.u==u && e.v==v) || (e.u==v && e.v==u)){
            // remove adjacency occurrences matching attributes
            auto remove_one = [&](int A,int B,const Edge &E)->bool{
                Adj** ptr = &g.head[A];
                while(*ptr){
                    Adj* cur = *ptr;
                    if(cur->to==B && cur->distance==E.distance && cur->install_cost==E.install_cost && cur->capacity==E.capacity && cur->loss_factor==E.loss_factor){
                        *ptr = cur->next; delete cur; return true;
                    }
                    ptr = &((*ptr)->next);
                }
                return false;
            };
            bool ok1 = remove_one(e.u, e.v, e);
            bool ok2 = remove_one(e.v, e.u, e);
            // mark edge invalid
            e.u = e.v = -1;
            // compact edges
            vector<Edge> tmp; tmp.reserve(g.edges.size());
            for(auto &ed: g.edges) if(ed.u != -1) tmp.push_back(ed);
            g.edges.swap(tmp);
            return ok1 && ok2;
        }
    }
    return false;
}

int remove_node(Graph &g, int x){
    if(x<0||x>=g.n) return 0;
    int removed = 0;
    // remove adjacency list for x and remove backrefs
    Adj* cur = g.head[x];
    while(cur){
        int nb = cur->to;
        // remove one node in nb's adj list that points to x with same attributes
        Adj** ptr = &g.head[nb];
        while(*ptr){
            Adj* c2 = *ptr;
            if(c2->to==x && c2->distance==cur->distance && c2->install_cost==cur->install_cost && c2->capacity==cur->capacity && c2->loss_factor==cur->loss_factor){
                *ptr = c2->next; delete c2; removed++; break;
            }
            ptr = &((*ptr)->next);
        }
        Adj* tmp = cur; cur = cur->next; delete tmp; removed++;
    }
    g.head[x] = nullptr;
    // invalidate edges with endpoint x
    for(auto &e: g.edges) if(e.u==x || e.v==x){ e.u = e.v = -1; e.distance=e.install_cost=e.capacity=e.loss_factor=0; }
    // compact
    vector<Edge> tmp; tmp.reserve(g.edges.size());
    for(auto &ed: g.edges) if(ed.u != -1) tmp.push_back(ed);
    g.edges.swap(tmp);
    return removed;
}

/* prioritize edges by attribute (printout) */
void prioritize_edges(Graph &g, const string &attr, const string &order){
    if(g.edges.empty()){ cout<<"No edges to prioritize.\n"; return; }
    vector<Edge> copy = g.edges;
    if(attr=="install_cost") sort(copy.begin(), copy.end(), [](const Edge&a,const Edge&b){ if(a.install_cost!=b.install_cost) return a.install_cost < b.install_cost; return a.distance < b.distance; });
    else if(attr=="distance") sort(copy.begin(), copy.end(), [](const Edge&a,const Edge&b){ if(a.distance!=b.distance) return a.distance < b.distance; return a.install_cost < b.install_cost; });
    else if(attr=="capacity") sort(copy.begin(), copy.end(), [](const Edge&a,const Edge&b){ if(a.capacity!=b.capacity) return a.capacity < b.capacity; return a.install_cost < b.install_cost; });
    else if(attr=="loss_factor") sort(copy.begin(), copy.end(), [](const Edge&a,const Edge&b){ if(a.loss_factor!=b.loss_factor) return a.loss_factor < b.loss_factor; return a.install_cost < b.install_cost; });
    else { cout<<"Unknown attribute '"<<attr<<"'\n"; return; }
    if(order=="DESC") reverse(copy.begin(), copy.end());
    for(auto &e: copy){
        cout<<"Edge "<<e.u<<"-"<<e.v<<" dist="<<e.distance<<" cost="<<e.install_cost<<" cap="<<e.capacity<<" loss="<<e.loss_factor<<"\n";
    }
}

void export_mst(const MSTResult &mst, const string &which){
    if(mst.chosen.empty()){ cout<<which<<" MST not available or graph disconnected.\n"; return; }
    cout<<which<<" MST total_install_cost = "<<mst.total_cost<<"\n";
    for(const auto &e: mst.chosen){
        cout<<e.u<<" "<<e.v<<" "<<e.distance<<" "<<e.install_cost<<" "<<e.capacity<<" "<<e.loss_factor<<"\n";
    }
}

/* ----------------- CSV parsing helpers ----------------- */

/* Trim helpers */
static inline string trim(const string &s){
    size_t i=0,j=s.size();
    while(i<j && isspace((unsigned char)s[i])) ++i;
    while(j>i && isspace((unsigned char)s[j-1])) --j;
    return s.substr(i,j-i);
}

/* Split CSV line into fields - handles simple quoted fields */
vector<string> split_csv_line(const string &line){
    vector<string> out;
    string cur;
    bool inq=false;
    for(size_t i=0;i<line.size();++i){
        char c = line[i];
        if(inq){
            if(c=='"'){
                if(i+1<line.size() && line[i+1]=='"'){ cur.push_back('"'); ++i; }
                else inq=false;
            } else cur.push_back(c);
        } else {
            if(c==','){ out.push_back(trim(cur)); cur.clear(); }
            else if(c=='"'){ inq=true; }
            else cur.push_back(c);
        }
    }
    out.push_back(trim(cur));
    return out;
}

/* Map header names to indices */
unordered_map<string,int> map_header(const vector<string> &hdr){
    unordered_map<string,int> mp;
    for(size_t i=0;i<hdr.size();++i){
        string key = hdr[i];
        // normalize to lower-case
        for(auto &ch: key) ch = tolower((unsigned char)ch);
        mp[key] = (int)i;
    }
    return mp;
}

string get_field(const vector<string> &fields, const unordered_map<string,int> &mp, const string &name){
    string nm = name;
    for(auto &ch: nm) ch = tolower((unsigned char)ch);
    auto it = mp.find(nm);
    if(it==mp.end()) return "";
    int idx = it->second;
    if(idx < 0 || idx >= (int)fields.size()) return "";
    return fields[idx];
}

/* parse ll safely */
ll parse_ll(const string &s){
    if(s.empty()) return 0;
    try{
        // allow floating numbers? but we treat as ll
        size_t pos=0;
        ll v = stoll(s, &pos);
        return v;
    } catch(...){
        // fallback: parse double and round
        try{
            double d = stod(s);
            return (ll) llround(d);
        } catch(...){
            return 0;
        }
    }
}

/* ----------------- Main CSV-driven command loop ----------------- */

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Read entire stdin into lines
    vector<string> lines;
    string row;
    bool any_input=false;
    while(std::getline(cin, row)){
        any_input = true;
        lines.push_back(row);
    }
    if(!any_input) return 0;

    // Detect CSV header if first non-empty line contains commas and is not a simple "mode" number
    int first_nonempty = -1;
    for(size_t i=0;i<lines.size();++i){
        string t = trim(lines[i]);
        if(!t.empty()){ first_nonempty = (int)i; break; }
    }
    if(first_nonempty==-1) return 0;

    bool is_csv = (lines[first_nonempty].find(',') != string::npos);

    // We'll support two modes:
    // - CSV Mode: header row + data rows (Option B)
    // - Legacy Mode: plain command lines (keeps backward compatibility)
    Graph g;
    MSTResult last_kruskal; last_kruskal.total_cost = INFLL;
    MSTResult last_prim; last_prim.total_cost = INFLL;
    vector<ll> last_dij;

    if(!is_csv){
        // fallback to legacy handling: treat each line as a command string (original behavior)
        // We'll build a temporary input stream from lines and process similar to earlier design
        // For brevity, we will simply print a message and exit (user previously had legacy functionality).
        cerr << "Non-CSV input detected. This build expects CSV Option B. Please provide CSV with header.\n";
        return 0;
    }

    // CSV parsing
    vector<string> header_fields = split_csv_line(lines[first_nonempty]);
    auto header_map = map_header(header_fields);

    // Expected header names (case-insensitive): command,u,v,distance,install_cost,capacity,loss_factor,extra
    // Process rows from first_nonempty+1 onward (or include first line if header is not first)
    for(size_t li = first_nonempty + 1; li < lines.size(); ++li){
        string raw = lines[li];
        if(trim(raw).empty()) continue;
        vector<string> fields = split_csv_line(raw);
        string command = get_field(fields, header_map, "command");
        if(command.empty()){
            // Optionally treat rows with "command" empty and with edge columns present as EDGE rows
            // If 'u' and 'v' present and distance non-empty, treat as EDGE
            string su = get_field(fields, header_map, "u");
            string sv = get_field(fields, header_map, "v");
            string sd = get_field(fields, header_map, "distance");
            if(!su.empty() && !sv.empty() && !sd.empty()){
                command = "EDGE";
            } else continue;
        }
        // Normalize command to uppercase
        string cmd_upper = command;
        for(auto &c: cmd_upper) c = toupper((unsigned char)c);
        // Extract numeric fields
        ll u = parse_ll(get_field(fields, header_map, "u"));
        ll v = parse_ll(get_field(fields, header_map, "v"));
        ll dist = parse_ll(get_field(fields, header_map, "distance"));
        ll cost = parse_ll(get_field(fields, header_map, "install_cost"));
        ll cap = parse_ll(get_field(fields, header_map, "capacity"));
        ll loss = parse_ll(get_field(fields, header_map, "loss_factor"));
        string extra = get_field(fields, header_map, "extra");

        // Process commands
        if(cmd_upper == "INIT"){
            int n = (int)u;
            int m_est = (int)v;
            if(n < 0) n = 0;
            if(n == 0){
                cerr << "INIT requires n>0 in column 'u'\n";
                g.init(0);
            } else {
                g.init(n);
            }
            // Note: we don't pre-read edges here; edges are read as EDGE rows present in CSV.
            cout << "Graph initialized: n=" << g.n << " (m estimate=" << m_est << ")\n";
            last_kruskal = MSTResult(); last_kruskal.total_cost = INFLL;
            last_prim = MSTResult(); last_prim.total_cost = INFLL;
            last_dij.clear();
        }
        else if(cmd_upper == "EDGE" || cmd_upper == "ADD_EDGE"){
            if(g.size() == 0){
                cerr << "Graph not initialized before EDGE / ADD_EDGE. Skipping.\n";
                continue;
            }
            g.addEdge((int)u, (int)v, dist, cost, cap, loss);
            cout << "Added edge " << u << "-" << v << " dist=" << dist << " cost=" << cost << " cap=" << cap << " loss=" << loss << "\n";
            last_kruskal = MSTResult(); last_kruskal.total_cost = INFLL;
            last_prim = MSTResult(); last_prim.total_cost = INFLL;
            last_dij.clear();
        }
        else if(cmd_upper == "RUN_ALL"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP RUN_ALL\n"; continue; }
            int source = (int)u;
            if(source < 0 || source >= g.n) source = 0;
            last_kruskal = kruskal_mst(g);
            last_prim = prim_mst(g, 0);
            last_dij = dijkstra(g, source);
            cout << "RUN_ALL completed. Kruskal=" << (last_kruskal.total_cost==INFLL? -1: last_kruskal.total_cost)
                 << " Prim=" << (last_prim.total_cost==INFLL? -1: last_prim.total_cost) << "\n";
        }
        else if(cmd_upper == "SHOW_KRUSKAL"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP SHOW_KRUSKAL\n"; continue; }
            if(last_kruskal.chosen.empty()) last_kruskal = kruskal_mst(g);
            export_mst(last_kruskal, "Kruskal");
        }
        else if(cmd_upper == "SHOW_PRIM"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP SHOW_PRIM\n"; continue; }
            if(last_prim.chosen.empty()) last_prim = prim_mst(g, 0);
            export_mst(last_prim, "Prim");
        }
        else if(cmd_upper == "SHOW_DIJKSTRA"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP SHOW_DIJKSTRA\n"; continue; }
            int src = (int)u;
            if(src < 0 || src >= g.n) src = 0;
            last_dij = dijkstra(g, src);
            cout << "Dijkstra from " << src << " (scaled by 1000):\n";
            for(int i=0;i<g.n;++i){
                if(last_dij[i] == INFLL) cout << i << ": INF\n"; else cout << i << ": " << fixed << setprecision(6) << (double)last_dij[i]/1000.0 << "\n";
            }
        }
        else if(cmd_upper == "CHECK_CONNECTIVITY"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP CHECK_CONNECTIVITY\n"; continue; }
            bool ok = is_connected(g);
            cout << "Connectivity: " << (ok?"Connected":"Disconnected") << "\n";
        }
        else if(cmd_upper == "REMOVE_EDGE"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP REMOVE_EDGE\n"; continue; }
            bool ok = remove_edge_uv(g, (int)u, (int)v);
            cout << "REMOVE_EDGE " << u << "-" << v << " => " << (ok?"Removed":"NotFound") << "\n";
            last_kruskal = MSTResult(); last_kruskal.total_cost = INFLL;
            last_prim = MSTResult(); last_prim.total_cost = INFLL;
            last_dij.clear();
        }
        else if(cmd_upper == "REMOVE_NODE"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP REMOVE_NODE\n"; continue; }
            int cnt = remove_node(g, (int)u);
            cout << "REMOVE_NODE " << u << " removed approx " << cnt << " items\n";
            last_kruskal = MSTResult(); last_kruskal.total_cost = INFLL;
            last_prim = MSTResult(); last_prim.total_cost = INFLL;
            last_dij.clear();
        }
        else if(cmd_upper == "PRIORITIZE_EDGES"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP PRIORITIZE_EDGES\n"; continue; }
            string attr; string ord;
            // expect extra like "install_cost ASC"
            {
                stringstream ss(extra);
                ss >> attr >> ord;
                if(attr.empty()){ cerr << "PRIORITIZE_EDGES requires 'extra' like: install_cost ASC\n"; continue; }
                if(ord.empty()) ord = "ASC";
                // normalize
                for(auto &c: attr) c = tolower((unsigned char)c);
                for(auto &c: ord) c = toupper((unsigned char)c);
            }
            prioritize_edges(g, attr, ord);
        }
        else if(cmd_upper == "EXPORT_MST"){
            if(g.size() == 0){ cerr << "Graph not initialized. SKIP EXPORT_MST\n"; continue; }
            string which = extra;
            for(auto &c: which) c = tolower((unsigned char)c);
            if(which == "kruskal") {
                if(last_kruskal.chosen.empty()) last_kruskal = kruskal_mst(g);
                export_mst(last_kruskal, "Kruskal");
            } else if(which == "prim"){
                if(last_prim.chosen.empty()) last_prim = prim_mst(g, 0);
                export_mst(last_prim, "Prim");
            } else cout << "EXPORT_MST requires extra 'kruskal' or 'prim'\n";
        }
        else if(cmd_upper == "QUIT"){
            cout<<"QUIT encountered. Stopping.\n";
            break;
        }
        else {
            cout << "Unknown command (CSV): " << command << "\n";
        }
    }

    return 0;
}
